import random
import time
import pandas as pd
import tweepy
import logging
from datetime import datetime, timedelta
from config import create_api

CONSUMER_KEY='gWvLL6hm5yFOxOU8zYmAWUGQU'
CONSUMER_SECRET='HCZnjm3o0UjlCBshVftrNYlkFdpNc5a6CkjatLug9qH9BP7dai'
ACCESS_TOKEN='1278836571190505473-aqNhgbLr6MTWAH2W3jBGpkI4jtik2v'
ACCESS_TOKEN_SECRET='JRoed08UNnTS6fQfkMqtgMIZD7yRHYo3PwApBvW06VEDk'

auth = tweepy.OAuthHandler(CONSUMER_KEY,CONSUMER_SECRET)
auth.set_access_token(ACCESS_TOKEN,ACCESS_TOKEN_SECRET)
api = tweepy.API(auth, wait_on_rate_limit=True, wait_on_rate_limit_notify=True)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()

selected_rows = []
#In my file all data is in the Lyrics column
def lyrics_tweet(last_tweeted):
    if last_tweeted < datetime.now()-timedelta(hours=3):
        # Read CSV file
        df = pd.read_csv('lyricsTheQueenisDead.csv', encoding='utf-8')

        rows = list(range(0, len(df.index)))
        rows = [i for i in rows if i not in selected_rows]
        if len(rows) == 0:
            api.update_status('(crossfading audio: time for next album...) \U0001F4BD \U0001F97A \U0001F44B')
            return last_tweeted
        else:
            try:
                readRow = random.choice(rows)
                selected_rows.append(readRow)
                tweet = str(df.iat[readRow, 2])
                api.update_status(tweet)
                logger.info(f'Tweeted {tweet} at {datetime.now().strftime("%d/%m/%y, %H:%M:%S")}')
                return datetime.now()
            except Exception as e:
                logger.error('Error posting tweet', exc_info=True)
    return last_tweeted    

# Likes all mentions
def fav_tweet(last_id):
    logger.info('Retrieving mentions')
    new_last_id = last_id

    for mention in tweepy.Cursor(api.mentions_timeline, last_id=last_id).items():
        new_last_id = max(mention.id, new_last_id)
        # Reply or own tweet
        if mention.in_reply_to_status_id is not None or mention.user.id == api.me().id:
            continue
        if not mention.favorited:
            try:
                mention.favorite()
                logger.info(f'Liked tweet by {mention.user.name}')
            except Exception as e:
                logger.error('Error faving tweet', exc_info=True)
    return new_last_id


def lambda_handler(event, context):
    last_tweeted = datetime.now() - timedelta(hours=3)
    last_id = 1

    while True:
        last_id = fav_tweet(last_id)
        last_tweeted = lyrics_tweet(last_tweeted)
        logger.info('Waiting...')
        time.sleep(60)
    